Project Orchestrator: A Master-Slave ESP-NOW Framework for the M5 Cardputer
Introduction: The Vision for Orchestrator
The "Orchestrator" project transforms the M5Stack Cardputer from a standalone, card-sized computer into a portable command-and-control center for a distributed network of devices. The core vision is to create a system where the Cardputer, acting as a master "Orchestrator," can seamlessly discover, manage, and issue commands to a swarm of subordinate "slave" devices. These slaves, which can be any generic ESP32 microcontroller, will automatically join the network upon being powered on, creating a robust and responsive system without the need for manual configuration or pre-shared credentials.

This report outlines the complete architectural design and provides the foundational firmware for this system. It is built upon three core pillars: the Master, a sophisticated user-facing application running on the M5 Cardputer ; the Slaves, a lightweight and generic firmware for any ESP32 board; and the Communication Fabric, a fast and efficient wireless protocol that binds them together. The initial implementation will focus on a core, practical application: a synchronized, distributed Wi-Fi scan, where the Orchestrator commands all slaves to scan their local airwaves and report their findings back to the master's display.

The following sections will provide a comprehensive technical deep-dive, covering the architectural decisions, the underlying communication protocols, and a complete, heavily commented walkthrough of the master and slave firmware. The final deliverable is a robust, extensible, and well-documented prototype, designed to serve as a powerful starting point for further development and experimentation.

Section 1: Architectural Blueprint: Designing for Simplicity and Power
The foundation of any robust system lies in its architecture. The choices made at this stage dictate the project's complexity, performance, and future extensibility. For Project Orchestrator, the design prioritizes simplicity and efficiency to meet the core requirements of a master-slave control system that is easy to build upon.

1.1. Master-Slave Star vs. True Mesh: Choosing the Right Topology
The request for a "mesh" network often implies a desire for a group of devices that work together in a coordinated fashion. However, it is critical to distinguish between the functional goal and the technical implementation. While a true mesh network is a powerful tool for decentralized data relay, the specific operational requirement for Project Orchestrator—a central master issuing commands to multiple slaves—is most effectively and simply realized using a Star Topology.

A true mesh network, such as that implemented by Espressif's ESP-WIFI-MESH protocol, allows numerous devices (nodes) to interconnect without a central hub. In this model, nodes are mutually responsible for relaying each other's transmissions, creating a self-organizing and self-healing network. This is ideal for applications where data must travel over long distances via multiple hops, or where there is no single point of control. Libraries like painlessMesh further simplify the creation of these ad-hoc networks. However, this architecture introduces significant overhead, including routing table management, node synchronization, and layer management, which is unnecessary for a master-slave system.

In contrast, the project's specified functionality is a classic star network: a central master communicates directly with multiple slaves. For this use case, the ESP-NOW protocol is the ideal solution. ESP-NOW is a connectionless, peer-to-peer communication protocol developed by Espressif that enables direct communication between devices without the need for a central router or complex network management. It is lightweight, extremely fast, and perfectly suited for the one-to-many broadcast and one-to-one response pattern required by the Orchestrator. By choosing a star topology implemented with ESP-NOW, the project avoids the complexity of a true mesh, resulting in a system that is more efficient, easier to debug, and simpler to extend.   

1.2. The Communication Fabric: A Deep Dive into ESP-NOW
ESP-NOW serves as the wireless backbone of the Orchestrator system. Its efficiency stems from its position in the networking stack. Unlike traditional Wi-Fi, which involves multiple layers of the OSI model, ESP-NOW operates primarily at the data-link layer, encapsulating application data directly into vendor-specific action frames. This streamlined process eliminates the overhead of complex packet headers and handshakes, resulting in very low-latency communication.   

The core concepts of ESP-NOW are fundamental to the Orchestrator's design:

MAC Address-Based Communication: All communication in ESP-NOW is directed to a device's unique Media Access Control (MAC) address. To send a message, the sender must know the MAC address of the receiver. This is the foundation of the "automagical" pairing process, where devices exchange their MAC addresses to establish a communication link.   

Callback Functions: ESP-NOW is an event-driven protocol. Instead of actively waiting for messages, the firmware registers callback functions that are automatically executed when an event occurs. The two primary callbacks are OnDataSent, which is triggered after a message is sent to confirm its delivery status, and OnDataRecv, which is triggered when a message is received. This asynchronous model is highly efficient and allows the main processor to perform other tasks, such as updating the UI, while waiting for network activity.   

Peer Management: Before two devices can communicate, they must be "paired." This is accomplished by the sender adding the receiver as a peer using the esp_now_add_peer() function. This function registers the receiver's MAC address and the Wi-Fi channel to be used for communication.   

While powerful, ESP-NOW has limitations that must be considered. The primary constraint is the maximum data payload of 250 bytes per message. For Project Orchestrator, which relies on sending short commands and receiving structured data packets, this limitation is perfectly acceptable and does not hinder the intended functionality.

1.3. The Development Environment: PlatformIO for Professional-Grade Projects
The choice of development environment is a critical factor in a project's long-term viability, especially for one intended to be extended by a developer who is still honing their skills. The M5 Cardputer supports several development platforms, including the Arduino IDE, ESP-IDF, and PlatformIO.   

Arduino IDE: While widely known for its simplicity and ease of entry, the Arduino IDE can become unwieldy for larger projects. Its management of library dependencies is manual, and its project structure can lead to disorganized code, making maintenance and collaboration difficult.   

ESP-IDF (Espressif IoT Development Framework): This is the native, official framework from Espressif. It offers unparalleled control over the ESP32's hardware and features, making it the choice for professional, performance-critical applications. However, it has a significantly steeper learning curve, requiring a deep understanding of FreeRTOS, build systems, and low-level C programming, which makes it unsuitable for the stated user profile.   

PlatformIO: This environment represents the ideal middle ground. It operates as an extension within a modern, professional code editor like Visual Studio Code and provides the "best of both worlds". It allows the use of the familiar and accessible Arduino framework, including its vast ecosystem of libraries, but within a structured and professional development environment. Its key advantage is the    

platformio.ini configuration file, which automates dependency management (lib_deps), ensures reproducible builds, and enforces a clean project structure. This provides the ease-of-use of Arduino with the rigor of a professional toolchain, making it the perfect choice for a project that needs to be both easy to start and robust enough to grow.   

Section 2: The Command Center: Setting Up the Cardputer Master
With the architectural decisions finalized, the next step is to establish the development environment and create the initial project structure for the Orchestrator master. This process uses PlatformIO within Visual Studio Code.

2.1. Installing PlatformIO and VS Code
Install Visual Studio Code: Download and install the latest version of VS Code from the official website.

Install the PlatformIO IDE Extension:

Open VS Code.

Navigate to the Extensions view by clicking the icon in the Activity Bar on the side of the window.

Search for "PlatformIO IDE".

Click "Install" on the official extension. The installation may take several minutes as it downloads and sets up the necessary toolchains and core components.

2.2. Creating the Orchestrator Project
Open the PlatformIO Home Screen: Click the PlatformIO icon in the VS Code Activity Bar to open the PIO Home tab.

Start a New Project: Click on "New Project".

Configure the Project:

Name: Orchestrator_Master

Board: Search for and select "Espressif ESP32-S3-DevKitC-1". This is the generic board definition that the M5StampS3 in the Cardputer is based on.   

Framework: Select "Arduino".

Location: Uncheck "Use default location" and choose a directory for your project.

Finish: Click "Finish". PlatformIO will create the project directory with the necessary subfolders and configuration files.

2.3. Deconstructing platformio.ini
The platformio.ini file is the brain of a PlatformIO project. It tells the build system everything it needs to know about the target hardware, framework, and dependencies. Open the platformio.ini file in the root of your Orchestrator_Master project and configure it as follows:

Ini, TOML

[env:m5stack-stamp-s3]
platform = espressif32
board = esp32-s3-devkitc-1
framework = arduino

; Serial Monitor options
monitor_speed = 115200

; Build options
build_flags = 
    -DARDUINO_USB_CDC_ON_BOOT=1
    -DARDUINO_USB_MODE=1

; Library dependencies
lib_deps = 
    m5stack/M5Unified
A detailed breakdown of this configuration:

platform = espressif32: Specifies that this project uses Espressif's platform toolchain.

board = esp32-s3-devkitc-1: Defines the target hardware. The M5StampS3 module at the heart of the Cardputer is an ESP32-S3.   

framework = arduino: The most critical choice, instructing PlatformIO to use the Arduino core for the ESP32. This provides access to familiar functions like setup(), loop(), and the vast Arduino library ecosystem.   

monitor_speed = 115200: Sets the default baud rate for the serial monitor, a standard for ESP32 development.

build_flags = -DARDUINO_USB_CDC_ON_BOOT=1: This flag is essential for enabling the USB serial (CDC) interface on the ESP32-S3 upon boot, allowing for reliable serial communication and debugging over the USB-C port.   

lib_deps = m5stack/M5Unified: This line is the key to simplifying development. It instructs PlatformIO to automatically find, download, and link the M5Unified library from the PlatformIO registry. This library provides a single, consistent API for interacting with all of the Cardputer's integrated hardware, including the display, keyboard, speaker, and power management ICs, abstracting away the complex low-level details.   

2.4. Project Structure Overview
PlatformIO creates a clean and logical directory structure:

.pio/: A hidden directory where PlatformIO stores compiled object files, firmware binaries, and downloaded libraries. This should not be modified manually.

include/: A place to put custom header files (.h).

lib/: A place for private libraries specific to this project.

src/: The source code for the application. The main firmware file, main.cpp, will be located here. You can rename it to Orchestrator_Master.ino if you prefer the .ino extension, and PlatformIO will handle it correctly.

platformio.ini: The project configuration file discussed above.

This structured approach is a significant advantage over the single-folder model of the Arduino IDE, promoting organized and maintainable code from the very beginning.

Section 3: The Master Firmware: Orchestrator_Master.ino
This section presents the complete, commented source code for the Cardputer master device. The code is designed to be robust, readable, and serve as a clear foundation for future expansion. It should be placed in the src/ directory of the PlatformIO project.

The firmware performs several key functions: it initializes the Cardputer hardware, establishes an ESP-NOW network, listens for and automatically pairs with new slaves, provides a command-line interface on the display, and processes commands to orchestrate the slave network.

C++

/*
 * Project Orchestrator - Master Firmware
 * 
 * Target: M5Stack Cardputer (ESP32-S3)
 * 
 * Description:
 * This firmware turns the M5 Cardputer into a master controller for a network
 * of ESP32 slaves. It uses the ESP-NOW protocol for fast, connectionless
 * communication.
 * 
 * Features:
 * - Initializes Cardputer hardware (Display, Keyboard) using M5Unified.
 * - Establishes an ESP-NOW network and listens for pairing requests.
 * - Automatically pairs with any slave that broadcasts a pairing request.
 * - Manages a list of connected slaves.
 * - Provides a simple command-line interface on the TFT display.
 * - Implements the 'scan' command to initiate a distributed Wi-Fi scan.
 * - Aggregates and displays results from slaves.
 * 
 */

// Core M5Stack library for unified hardware access
#include <M5Unified.h>

// Libraries for ESP-NOW and Wi-Fi functionality
#include <esp_now.h>
#include <WiFi.h>
#include <vector>

// =================================================================
// == DATA STRUCTURES & DEFINITIONS
// =================================================================

// Define a structure for each slave device in our network
struct SlaveDevice {
    uint8_t mac_addr;
    // Future additions: status, last_seen, etc.
};

// Define the structure of data packets for communication.
// Using structs ensures both master and slave interpret data identically.
enum MessageType : uint8_t {
    PAIRING_REQUEST,
    PAIRING_RESPONSE,
    COMMAND_PACKET,
    SCAN_RESULT_PACKET
};

struct __attribute__((packed)) DataPacketHeader {
    MessageType type;
};

struct __attribute__((packed)) CommandPacket {
    DataPacketHeader header;
    char command;
    char args;
};

struct __attribute__((packed)) ScanResultPacket {
    DataPacketHeader header;
    char ssid; // SSID can be up to 32 chars + null terminator
    int32_t rssi;
    uint8_t channel;
    uint8_t mac_reporter; // MAC of the slave that found this network
};


// =================================================================
// == GLOBAL VARIABLES
// =================================================================

// A vector to dynamically store information about connected slaves
std::vector<SlaveDevice> slaves;

// UI-related variables
M5Canvas canvas(&M5.Display);
String command_buffer = "";
const int MAX_LOG_LINES = 8;
String log_lines;
int current_log_line = 0;

// =================================================================
// == UTILITY & UI FUNCTIONS
// =================================================================

// Helper function to convert a MAC address to a String for display
String macToString(const uint8_t* mac) {
    char buf;
    snprintf(buf, sizeof(buf), "%02X:%02X:%02X:%02X:%02X:%02X",
             mac, mac, mac, mac, mac, mac);
    return String(buf);
}

// Add a message to the scrolling log on the display
void addLog(String message) {
    log_lines[current_log_line] = message;
    current_log_line = (current_log_line + 1) % MAX_LOG_LINES;
}

// Redraw the entire UI. Called after major changes.
void drawUI() {
    M5.Display.fillScreen(BLACK);
    
    // Header
    M5.Display.fillRect(0, 0, M5.Display.width(), 16, DARKGREY);
    M5.Display.setTextColor(WHITE, DARKGREY);
    M5.Display.setTextDatum(MC_DATUM);
    M5.Display.drawString("Orchestrator v0.1", M5.Display.width() / 2, 8);
    
    // Slave count
    M5.Display.setTextDatum(TL_DATUM);
    M5.Display.setTextColor(CYAN);
    String slave_count_str = "Slaves: " + String(slaves.size());
    M5.Display.drawString(slave_count_str, 5, 20);

    // Log area
    M5.Display.setTextColor(WHITE);
    M5.Display.setTextSize(1);
    for (int i = 0; i < MAX_LOG_LINES; i++) {
        int line_index = (current_log_line + i) % MAX_LOG_LINES;
        if (log_lines[line_index].length() > 0) {
            M5.Display.drawString(log_lines[line_index], 5, 35 + i * 10);
        }
    }
    
    // Command input area
    M5.Display.drawFastHLine(0, M5.Display.height() - 20, M5.Display.width(), WHITE);
    M5.Display.setTextColor(GREEN);
    M5.Display.drawString("> " + command_buffer, 5, M5.Display.height() - 15);
}

// Check if a slave with a given MAC address is already known
bool isSlaveKnown(const uint8_t* mac) {
    for (const auto& slave : slaves) {
        if (memcmp(slave.mac_addr, mac, 6) == 0) {
            return true;
        }
    }
    return false;
}

// =================================================================
// == ESP-NOW CALLBACK FUNCTIONS
// =================================================================

// Callback function executed when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
    // For now, we don't need to do much here. Could add logging for failed sends.
    // Serial.print("Last Packet Send Status: ");
    // Serial.println(status == ESP_NOW_SEND_SUCCESS? "Delivery Success" : "Delivery Fail");
}

// Callback function executed when data is received
void OnDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len) {
    DataPacketHeader* header = (DataPacketHeader*)incomingData;

    switch (header->type) {
        case PAIRING_REQUEST: {
            if (!isSlaveKnown(mac)) {
                // A new slave wants to pair. Add it.
                SlaveDevice new_slave;
                memcpy(new_slave.mac_addr, mac, 6);
                slaves.push_back(new_slave);

                // Add peer to ESP-NOW
                esp_now_peer_info_t peerInfo = {};
                memcpy(peerInfo.peer_addr, mac, 6);
                peerInfo.channel = 0; // Use default channel
                peerInfo.encrypt = false;
                if (esp_now_add_peer(&peerInfo)!= ESP_OK) {
                    addLog("Failed to add peer");
                    // Remove from our list if ESP-NOW fails
                    slaves.pop_back(); 
                    return;
                }
                
                // Send a response to confirm pairing
                DataPacketHeader responseHeader;
                responseHeader.type = PAIRING_RESPONSE;
                esp_now_send(mac, (uint8_t*)&responseHeader, sizeof(responseHeader));

                addLog("Paired: " + macToString(mac));
                drawUI(); // Update UI with new slave count
            }
            break;
        }

        case SCAN_RESULT_PACKET: {
            ScanResultPacket* result = (ScanResultPacket*)incomingData;
            String log_msg = macToString(result->mac_reporter) + " found " +
                             String(result->ssid) + " (" + String(result->rssi) + "dBm)";
            addLog(log_msg);
            drawUI(); // Update UI with new scan result
            break;
        }

        default:
            // Unknown packet type
            addLog("Unknown packet from " + macToString(mac));
            drawUI();
            break;
    }
}

// =================================================================
// == SETUP
// =================================================================

void setup() {
    // Initialize M5Stack hardware. The 'true' argument enables all peripherals.
    auto cfg = M5.config();
    M5.begin(cfg);

    // The Cardputer screen is landscape, but oriented strangely.
    // Rotation 1 is the correct orientation for holding it.
    M5.Display.setRotation(1);
    M5.Display.setTextSize(2);
    M5.Display.fillScreen(BLACK);

    // Initialize Wi-Fi in Station mode for ESP-NOW
    WiFi.mode(WIFI_STA);
    // Optional: Get the MAC address for debugging
    // Serial.begin(115200);
    // Serial.print("Master MAC Address: ");
    // Serial.println(WiFi.macAddress());

    // Initialize ESP-NOW
    if (esp_now_init()!= ESP_OK) {
        M5.Display.println("Error initializing ESP-NOW");
        return;
    }

    // Register the callback functions
    esp_now_register_send_cb(OnDataSent);
    esp_now_register_recv_cb(OnDataRecv);

    // Initial UI draw
    addLog("Orchestrator Online.");
    addLog("Awaiting slaves...");
    drawUI();
}

// =================================================================
// == MAIN LOOP
// =================================================================

void loop() {
    // M5.update() is crucial. It polls the keyboard and other hardware.
    M5.update();

    // Check for keyboard input
    if (M5.Keyboard.isChange()) {
        if (M5.Keyboard.isPressed()) {
            Keyboard_Class::KeysState status = M5.Keyboard.keysState();

            // Handle character keys
            for (auto c : status.word) {
                command_buffer += c;
            }

            // Handle backspace/delete
            if (status.del && command_buffer.length() > 0) {
                command_buffer.remove(command_buffer.length() - 1);
            }

            // Handle enter key to execute command
            if (status.enter) {
                addLog("> " + command_buffer);
                
                // --- COMMAND PARSING ---
                if (command_buffer == "scan") {
                    // Broadcast the scan command to all paired slaves
                    CommandPacket cmd;
                    cmd.header.type = COMMAND_PACKET;
                    strcpy(cmd.command, "scan");
                    strcpy(cmd.args, "");
                    
                    // Sending to NULL MAC address broadcasts to all peers
                    esp_now_send(NULL, (uint8_t*)&cmd, sizeof(cmd)); 
                    addLog("Broadcast: SCAN");

                } else if (command_buffer == "clear") {
                    for(int i=0; i<MAX_LOG_LINES; i++) log_lines[i] = "";
                    addLog("Logs cleared.");

                } else if (command_buffer == "help") {
                    addLog("Cmds: scan, clear, help");
                
                } else {
                    addLog("Unknown command.");
                }

                command_buffer = ""; // Clear buffer after execution
            }

            // Redraw the UI to show the updated command buffer or log
            drawUI();
        }
    }
}
3.1. Includes and Global Definitions
The firmware begins by including the necessary libraries. M5Unified.h is the most critical, providing a high-level API for all the Cardputer's hardware.   

esp_now.h and WiFi.h provide the communication functions. A C++ std::vector is used to store a list of connected slaves, which is more flexible than a fixed-size array.

Crucially, this section defines the data structures used for communication. Using C++ structs is a best practice for ESP-NOW as it ensures data alignment and type consistency between the sender and receiver. An    

enum for MessageType allows the receiving end to easily identify the purpose of a packet and cast it to the correct struct pointer for processing. The __attribute__((packed)) directive is used to prevent the compiler from adding padding bytes, ensuring the struct's memory layout is identical across different devices and compiler versions.

3.2. The setup() Function: Awakening the Orchestrator
The setup() function is responsible for initializing the system.

M5.begin(): This single, powerful function from the M5Unified library initializes the display controller (ST7789V2), keyboard controller (74HC138), power management IC, and other peripherals based on the Cardputer's hardware profile.   

Display Configuration: The screen is a 240x135 pixel TFT. M5.Display.setRotation(1) orients the display correctly for handheld use.

Wi-Fi and ESP-NOW Initialization: WiFi.mode(WIFI_STA) sets the device into Wi-Fi Station mode, which is a prerequisite for using ESP-NOW. esp_now_init() initializes the ESP-NOW subsystem.   

Registering Callbacks: esp_now_register_send_cb(OnDataSent) and esp_now_register_recv_cb(OnDataRecv) are the most important setup steps for communication. They tell the ESP-NOW system which functions to call automatically when data is sent or received, forming the basis of the event-driven architecture.

3.3. The "Automagical" Handshake: Master-Side Pairing Logic
The core of the seamless pairing process resides in the OnDataRecv callback function. This function is triggered every time an ESP-NOW packet arrives. The logic is as follows:

The function first inspects the MessageType of the incoming packet.

If the type is PAIRING_REQUEST, it means a new slave is trying to join the network.

The master checks if it already knows the slave's MAC address using the isSlaveKnown() helper function.

If the slave is new, the master adds its MAC address to the slaves vector for internal tracking.

It then calls esp_now_add_peer(), officially registering the slave with the ESP-NOW system so it can send unicast messages to it in the future.   

Finally, it sends a PAIRING_RESPONSE packet directly back to the new slave's MAC address to confirm that the pairing was successful. This completes the handshake. This entire discovery and response cycle is derived from established auto-pairing techniques.   

3.4. The User Interface (UI) and Keyboard Control
The main loop() is kept clean and responsive. Its primary responsibility is to call M5.update() and handle keyboard input.

M5.update(): This function, provided by the M5Unified library, must be called repeatedly. It handles background tasks like polling the keyboard matrix and updating button states. Without this call, keyboard input would not be detected.   

Keyboard Input: The code checks M5.Keyboard.isChange() and M5.Keyboard.isPressed() to detect new key events. The M5.Keyboard.keysState() method returns a structure containing the character pressed, as well as the state of special keys like del and enter. The firmware uses this to build up a    

command_buffer string.

Command Execution: When the enter key is detected, the command_buffer is parsed. For this initial version, it recognizes "scan", "clear", and "help". The "scan" command triggers a broadcast message to all paired slaves.

UI Drawing: A dedicated function, drawUI(), is used to render the screen. It draws a header, the current slave count, a scrolling log area, and the command input line. Calling a single function to redraw the screen keeps the main loop tidy and centralizes all display logic.

Table 1: Orchestrator Command & Navigation Keys
This table provides a clear reference for operating the Orchestrator, mapping the Cardputer's physical keys to the firmware's functions.

Key(s)

Action

Description

[a-z], [0-9], [symbols]

Type Command

Appends the character to the command input buffer.

[Enter]

Execute Command

Processes the current command buffer.

``

Backspace

Deletes the last character from the command input buffer.

scan

Initiate Scan

Broadcasts a command for all slaves to perform a Wi-Fi scan.

clear

Clear Logs

Clears the log display area on the screen.

help

Show Help

Displays a list of available commands in the log area.

[Arrow Keys]

(Future Use)

Reserved for future features like command history or menu navigation.


Export to Sheets
Section 4: The Slave Firmware: Orchestrator_Slave.ino
This firmware is designed to be generic and lightweight. It can be flashed onto any standard ESP32 development board (such as an ESP32-DevKitC, NodeMCU-32S, etc.) to turn it into an Orchestrator slave. Its sole purpose is to find and pair with the master, then passively await and execute commands. This code should be created as a separate PlatformIO project named Orchestrator_Slave. The platformio.ini for the slave will be simpler, only requiring the espressif32 platform and a standard ESP32 board definition.

C++

/*
 * Project Orchestrator - Slave Firmware
 * 
 * Target: Generic ESP32
 * 
 * Description:
 * This firmware turns any ESP32 board into a slave node for the Orchestrator
 * master. It automatically searches for and pairs with the master upon startup.
 * 
 * Features:
 * - Initializes ESP-NOW and Wi-Fi.
 * - Automatically scans Wi-Fi channels to find the master.
 * - Broadcasts pairing requests until a response is received.
 * - Once paired, it passively waits for commands from the master.
 * - Executes commands (e.g., Wi-Fi scan) and reports results back.
 * 
 */

#include <esp_now.h>
#include <WiFi.h>
#include "esp_wifi.h" // For advanced functions like esp_wifi_set_channel

// =================================================================
// == DATA STRUCTURES & DEFINITIONS
// =================================================================

// These structures MUST be identical to the ones in the master firmware.
enum MessageType : uint8_t {
    PAIRING_REQUEST,
    PAIRING_RESPONSE,
    COMMAND_PACKET,
    SCAN_RESULT_PACKET
};

struct __attribute__((packed)) DataPacketHeader {
    MessageType type;
};

struct __attribute__((packed)) CommandPacket {
    DataPacketHeader header;
    char command;
    char args;
};

struct __attribute__((packed)) ScanResultPacket {
    DataPacketHeader header;
    char ssid;
    int32_t rssi;
    uint8_t channel;
    uint8_t mac_reporter;
};

// =================================================================
// == GLOBAL VARIABLES
// =================================================================

// MAC address of the master. FF:FF:FF:FF:FF:FF is a broadcast address.
uint8_t masterAddress = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

// Pairing status
bool isPaired = false;
int wifi_channel = 1;

// Timing for pairing attempts
unsigned long lastPairRequestTime = 0;
const long pairRequestInterval = 2000; // Try to pair every 2 seconds

// =================================================================
// == ESP-NOW CALLBACK FUNCTIONS
// =================================================================

void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
    Serial.print("\r\nLast Packet Send Status:\t");
    Serial.println(status == ESP_NOW_SEND_SUCCESS? "Delivery Success" : "Delivery Fail");
}

void OnDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len) {
    DataPacketHeader* header = (DataPacketHeader*)incomingData;
    
    if (isPaired) {
        // If we are already paired, we only care about command packets
        if (header->type == COMMAND_PACKET) {
            CommandPacket* cmd = (CommandPacket*)incomingData;
            Serial.print("Command received: ");
            Serial.println(cmd->command);

            if (strcmp(cmd->command, "scan") == 0) {
                // --- EXECUTE WIFI SCAN ---
                Serial.println("Starting Wi-Fi scan...");
                int n = WiFi.scanNetworks();
                Serial.print(n);
                Serial.println(" networks found.");

                if (n > 0) {
                    for (int i = 0; i < n; ++i) {
                        ScanResultPacket result;
                        result.header.type = SCAN_RESULT_PACKET;
                        
                        // Copy SSID and ensure null termination
                        strncpy(result.ssid, WiFi.SSID(i).c_str(), 32);
                        result.ssid = '\0';
                        
                        result.rssi = WiFi.RSSI(i);
                        result.channel = WiFi.channel(i);
                        memcpy(result.mac_reporter, WiFi.macAddress().c_str(), 6);

                        // Send the result back to the master
                        esp_now_send(masterAddress, (uint8_t *)&result, sizeof(result));
                        delay(20); // Small delay to avoid flooding
                    }
                }
                Serial.println("Scan report complete.");
            }
        }
    } else {
        // If not paired, we are only looking for a pairing response
        if (header->type == PAIRING_RESPONSE) {
            Serial.println("Pairing response received from master!");
            
            // The master has responded. Store its MAC address.
            memcpy(masterAddress, mac, 6);

            // Add the master as a peer
            esp_now_peer_info_t peerInfo = {};
            memcpy(peerInfo.peer_addr, masterAddress, 6);
            peerInfo.channel = wifi_channel; // Use the channel we found it on
            peerInfo.encrypt = false;

            if (esp_now_add_peer(&peerInfo)!= ESP_OK) {
                Serial.println("Failed to add master peer");
                return;
            }
            
            isPaired = true;
            Serial.print("Successfully paired with master: ");
            Serial.printf("%02X:%02X:%02X:%02X:%02X:%02X\n", mac, mac, mac, mac, mac, mac);
        }
    }
}

// =================================================================
// == SETUP
// =================================================================

void setup() {
    Serial.begin(115200);
    Serial.println("Orchestrator Slave Booting...");

    // Set device as a Wi-Fi Station
    WiFi.mode(WIFI_STA);
    WiFi.disconnect(); // Disconnect from any previous network

    // Init ESP-NOW
    if (esp_now_init()!= ESP_OK) {
        Serial.println("Error initializing ESP-NOW");
        return;
    }

    // Register callbacks
    esp_now_register_send_cb(OnDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    
    Serial.println("Ready to find master...");
}

// =================================================================
// == MAIN LOOP
// =================================================================

void loop() {
    if (!isPaired) {
        // If not paired, keep trying to find the master
        if (millis() - lastPairRequestTime > pairRequestInterval) {
            lastPairRequestTime = millis();

            // Cycle through Wi-Fi channels
            wifi_channel++;
            if (wifi_channel > 13) {
                wifi_channel = 1;
            }
            esp_wifi_set_channel(wifi_channel, WIFI_SECOND_CHAN_NONE);
            
            Serial.print("Broadcasting pairing request on channel ");
            Serial.println(wifi_channel);

            // Broadcast a pairing request to all devices on the current channel
            DataPacketHeader requestHeader;
            requestHeader.type = PAIRING_REQUEST;

            // Add broadcast peer to send the message
            esp_now_peer_info_t peerInfo = {};
            memcpy(peerInfo.peer_addr, masterAddress, 6); // masterAddress is broadcast FF:FF...
            peerInfo.channel = wifi_channel;
            peerInfo.encrypt = false;
            
            if (esp_now_add_peer(&peerInfo)!= ESP_OK) {
                // If it fails, it might be because it's already there. Try deleting and re-adding.
                esp_now_del_peer(masterAddress);
                esp_now_add_peer(&peerInfo);
            }
            
            esp_now_send(masterAddress, (uint8_t *)&requestHeader, sizeof(requestHeader));
        }
    } else {
        // We are paired. Do nothing and wait for commands.
        // The ESP32 will automatically handle incoming packets via the callback.
        // For power saving, a `delay()` or light sleep could be added here.
        delay(100);
    }
}
4.1. Includes and Global Definitions
The slave firmware includes the same core communication libraries. It is paramount that the struct definitions for data packets are an exact, byte-for-byte match with the master's firmware. Any discrepancy will lead to data corruption and communication failure.

4.2. The setup() Function: Slave Initialization
The slave's setup is much simpler than the master's. It initializes the serial port for debugging, sets the Wi-Fi mode to WIFI_STA, and initializes the ESP-NOW system, registering the same OnDataSent and OnDataRecv callbacks.

4.3. The Main loop() and Finding the Master
The slave's main loop embodies the "automagical" pairing logic. It operates in two distinct states controlled by the isPaired boolean flag.

Unpaired State (isPaired == false): This is the active "hunting" phase. The system must find the master without any prior knowledge of its MAC address or Wi-Fi channel. This is achieved through a carefully choreographed broadcast and discovery process:

The slave iterates through Wi-Fi channels 1 through 13. This is necessary because ESP-NOW communication can only occur between devices on the same channel. The    

esp_wifi_set_channel() function is used to hop to the next channel.

On each channel, the slave broadcasts a PAIRING_REQUEST packet. This is sent to the special broadcast MAC address FF:FF:FF:FF:FF:FF, which ensures all ESP-NOW devices on that channel will receive it.   

The slave then waits for a short interval before hopping to the next channel and repeating the broadcast.

The OnDataRecv Callback (Pairing): While hunting, the slave is listening for a PAIRING_RESPONSE. When this packet arrives, the slave knows it has successfully found the master. The callback function then:

Extracts the master's MAC address from the incoming packet's sender information.

Stores this MAC address in the masterAddress variable for all future communication.

Adds the master as its one and only peer using esp_now_add_peer().

Sets the isPaired flag to true, transitioning to the passive state.

Paired State (isPaired == true): Once paired, the slave's job is simple. The main loop becomes idle, passively awaiting commands. All further work is handled by the OnDataRecv callback when a COMMAND_PACKET arrives from the master.

Section 5: The First Directive: Implementing the Synchronized Wi-Fi Scan
This section details the full data flow for the project's primary feature: commanding all slaves to perform a Wi-Fi scan and report their findings. This demonstrates the power of the Orchestrator's architecture.

5.1. Master: Issuing the SCAN Command
The process begins on the Cardputer. When the user types "scan" and presses Enter, the master's firmware executes the scan command block. It constructs a CommandPacket with the type COMMAND_PACKET and the command string "scan". It then calls esp_now_send() with a NULL destination address. In ESP-NOW, sending to NULL acts as a broadcast, sending the packet to every peer that has been added to the master's list. This single action efficiently commands the entire swarm of slaves simultaneously.   

5.2. Slave: Executing the Scan and Reporting Back
Each slave in the network receives the broadcasted CommandPacket in its OnDataRecv callback.

The callback identifies the command as "scan".

It then calls the standard Arduino WiFi.scanNetworks() function. This is a blocking function that performs a complete scan of all 2.4 GHz Wi-Fi channels, returning the number of access points found.   

The slave then iterates through the scan results. For each network discovered, it populates a ScanResultPacket with the network's SSID, RSSI (signal strength), and the slave's own MAC address.

Each of these result packets is sent directly back to the master using a unicast esp_now_send() call directed at the stored masterAddress.

5.3. Master: Aggregating and Displaying Results
The master's OnDataRecv callback is once again triggered, this time receiving a stream of ScanResultPackets from all the slaves in the network.

For each incoming packet, the master parses the data.

It formats the information into a human-readable string, for example: "A1:B2:C3:D4:E5:F6 found MyWifi (-55dBm)".

This string is added to the scrolling log on the Cardputer's display using the addLog() and drawUI() functions.
The result is a real-time, aggregated view of the Wi-Fi environment across a wide physical area, as seen by the entire swarm of distributed slaves.

Table 2: Data Flow for the Distributed Scan Command
This table visualizes the entire multi-step communication sequence for the scan command.

Step

Origin

Destination

Protocol/Action

Data Payload (Simplified)

1

Master

All Paired Slaves

ESP-NOW Broadcast

CommandPacket { type: COMMAND, cmd: "scan" }

2

Slave 1

(Internal)

WiFi.scanNetworks()

(Performs local Wi-Fi scan)

3

Slave 2

(Internal)

WiFi.scanNetworks()

(Performs local Wi-Fi scan)

4

Slave 1

Master

ESP-NOW Unicast

ScanResultPacket { type: SCAN_RESULT, ssid: "NetA",... }

5

Slave 2

Master

ESP-NOW Unicast

ScanResultPacket { type: SCAN_RESULT, ssid: "NetB",... }

6

Slave 1

Master

ESP-NOW Unicast

ScanResultPacket { type: SCAN_RESULT, ssid: "NetC",... }

7

Master

(Internal UI)

addLog() & drawUI()

Displays aggregated results from all slaves.


Export to Sheets
Section 6: Advanced Operations: An Introduction to Wi-Fi Disruption
To fulfill the request for "fun" and creative applications, this section explores the implementation of a Wi-Fi de-authentication command. It is presented not just as a tool, but with the necessary technical and security context to provide a nuanced, expert-level understanding.

6.1. The Theory of De-authentication Attacks
The 802.11 Wi-Fi standard includes "management frames" that control the state of wireless connections. Two of these are the de-authentication and disassociation frames. Historically, these management frames were sent unencrypted, even on password-protected networks. This creates a vulnerability: an attacker can "spoof" a de-authentication frame, pretending it came from the legitimate Access Point (AP), and send it to a connected client. The client, believing the frame is authentic, will immediately disconnect from the network. By repeatedly sending these frames, an attacker can create a sustained Denial-of-Service (DoS) attack, preventing clients from maintaining a connection.   

6.2. Implementing the deauth Command
A basic de-authentication broadcast can be achieved using a function within the ESP-IDF's Wi-Fi library. This functionality is not exposed in the standard Arduino WiFi.h library, but it can be called directly. The implementation would be added as a new command in the master firmware's loop() function.

When the user types deauth [channel] and hits enter:

The master parses the target channel from the command arguments.

It sets its own Wi-Fi channel to match the target's channel using esp_wifi_set_channel(). This is crucial for the attack to be effective.

The master temporarily enables Soft AP mode using WiFi.softAP("dummy_ap"). This is a prerequisite for calling the de-authentication function.   

The core of the attack is the call to esp_wifi_deauth_sta(0). This function broadcasts a de-authentication frame on the current channel. The    

0 argument signifies a broadcast to all stations.

Immediately after, the Soft AP is turned off with WiFi.softAPdisconnect(true).

This sequence sends a burst of de-authentication packets on the specified channel, potentially disrupting nearby Wi-Fi connections. A more advanced implementation could distribute this task, commanding each slave to perform the de-auth on a specific channel, effectively jamming multiple networks simultaneously.

6.3. The Modern Reality: Why This Might Not Work
It is critical to understand that this classic attack is becoming increasingly ineffective against modern, secure networks. The WPA3 security standard, and even many WPA2-implementations, mandate a feature called Protected Management Frames (PMF), also known as 802.11w.   

PMF solves this vulnerability by encrypting critical management frames, including de-authentication and disassociation frames. When a client is connected to an AP with PMF enabled, it will simply discard any unencrypted de-authentication frames it receives. Since the frames spoofed by our Orchestrator are unencrypted, they will be ignored by any client on a WPA3-secured network. Therefore, while this command is a powerful demonstration of a classic Wi-Fi vulnerability, its practical effect is limited to older or insecurely configured (WPA2 without PMF, WEP, or Open) networks. Providing this context is essential for managing expectations and delivering a truly expert-level analysis.   

Section 7: The Public Debut: Crafting a Professional README.md
A well-written README.md is the front door to any open-source project. It should be clear, concise, and provide all the information a new user needs to get started. The following is a complete, professional README.md file ready for the Orchestrator GitHub repository.

`# Project Orchestrator

Project Orchestrator is a firmware framework that transforms the M5Stack Cardputer into a portable command-and-control center for a network of ESP32 devices. The Cardputer acts as a "Master," while any generic ESP32 can be flashed with the "Slave" firmware.

The system uses the fast and efficient ESP-NOW protocol for communication, featuring a seamless auto-pairing mechanism where slaves automatically discover and connect to the master upon startup.

Features
Master-Slave Architecture: Centralized command and control from the Cardputer.

ESP-NOW Communication: Lightweight, fast, and connectionless wireless protocol.

"Automagical" Auto-Pairing: Slaves automatically find and pair with the master without any pre-configuration. Just power them on and they join the network.

Synchronized Distributed Scanning: Issue a single scan command to make all slaves perform a Wi-Fi scan of their surroundings and report the results back to the master's display.

Extensible Command System: Easily add new commands and functionality to both the master and slave firmware.

Hardware Required
Master: 1 x(https://shop.m5stack.com/products/m5stack-cardputer-kit-w-m5stamps3) (v1.0 or v1.1)

Slave(s): 1 or more generic ESP32 development boards (e.g., ESP32-DevKitC, NodeMCU-32S).

Setup and Installation
This project is built using the PlatformIO IDE within Visual Studio Code.

Install VS Code and PlatformIO:

Download and install(https://code.visualstudio.com/).

Open VS Code, go to the Extensions tab, search for PlatformIO IDE, and install it.

**Clone the Repository:**bash
git clone https://github.com/your-username/Orchestrator.git
cd Orchestrator


Flash the Master Firmware:

Open the Orchestrator_Master folder in VS Code. PlatformIO should recognize it as a project.

Connect your Cardputer to your computer via USB-C.

To enter download mode, press and hold the G0 button on the side of the Cardputer before powering it on or connecting the cable. Release it after power is applied.

Click the "Upload" button (arrow icon) in the PlatformIO toolbar at the bottom of the VS Code window.

Flash the Slave Firmware:

Open the Orchestrator_Slave folder in VS Code.

Connect a generic ESP32 board to your computer.

Click the "Upload" button in the PlatformIO toolbar.

Repeat for as many slave devices as you have.

Usage
Once the master and slave(s) are flashed, power them on. The slaves will automatically begin searching for the master. As each slave pairs successfully, the "Slaves:" count on the Cardputer's display will increase, and a "Paired" message will appear in the log.

You can then use the Cardputer's keyboard to enter commands.

Command

Description

scan

Broadcasts a command for all slaves to perform a Wi-Fi scan. Results will appear in the log.

clear

Clears the log display on the screen.

help

Displays a list of available commands.


Export to Sheets
Future Development
This project provides a solid foundation. Future enhancements could include:

More Commands: Implement ping to check slave status, reboot to remotely restart a slave, or commands to read from sensors connected to slaves.

SD Card Logging: Save scan results and event logs to the Cardputer's Micro SD card.

Advanced UI: Create different screens for viewing detailed slave information or visualizing scan data.

Encrypted Communication: Implement ESP-NOW encryption by adding a shared key (PMK) for secure communication.


## **Conclusion and Future Roadmap**

This report has detailed the design and implementation of Project Orchestrator, a robust and extensible master-slave framework. By making deliberate architectural choices—prioritizing a simple star topology with ESP-NOW over a complex mesh, and selecting PlatformIO as a professional yet accessible development environment—a powerful foundation has been established. The resulting system successfully achieves the core vision: a Cardputer master that can "automagically" discover and command a network of ESP32 slaves, with a functional, distributed Wi-Fi scanning application as a proof-of-concept.

The provided firmware is not an endpoint, but a starting point. The architecture is designed for growth. The following curated list of next steps can guide the project's future development:

*   **Enhance the Command Set:** Introduce new commands such as `ping <mac>` to check a specific slave's responsiveness, `uptime` to query how long a slave has been online, or `reboot <mac>` to remotely restart a device.
*   **Implement SD Card Logging:** Leverage the Cardputer's built-in Micro SD card slot [9] to log all events, scan results, and slave connections to a file. This would provide persistent data storage that survives a reboot.
*   **Develop a Richer UI:** Move beyond the single-screen log. Use the arrow keys to navigate between different "apps" or views on the Cardputer: a "Slave Manager" screen to list all peers and their status, a "Scan Visualizer" to show a graphical representation of network strengths, and a "Settings" screen.
*   **Secure the Network:** The current implementation uses unencrypted ESP-NOW for simplicity. The next logical step is to add a pre-shared key (PMK) to both the master and slave firmware to enable CCMP encryption, protecting all communication from eavesdropping.
*   **Integrate a Web Interface:** The master ESP32-S3 is more than capable of hosting a simple web server simultaneously with ESP-NOW.[21] A web interface could provide a rich, graphical dashboard for viewing network status and results from any device on the same Wi-Fi network as the master.
*   **Explore Other Payloads:** The current system is built for Wi-Fi scanning. It could easily be adapted to orchestrate other tasks: distributed sensor reading (temperature, pressure), coordinated infrared blasting using the Cardputer's IR emitter [16], or even simple distributed computing tasks.

By following this roadmap, Project Orchestrator can evolve 
